/*
 * zx_kernel_body.c
 *
 * Apart from the kernel loop, main fucntion calls with which the 
 * the kernel continously schedules and runs one task after other
 * These routines constitute the core of the kernel
 *
 * Authors : Alex Murashkin
 *           Priyaa Varshinee
 */

#include <ts7200.h>

#include <zx_helper.h>
#include <zx_system_call_handlers.h>
#include <zx_kernel_body.h>
#include <zx_kernel_config.h>
#include <zx_tasks.h>
#include <zx_ready_queue.h>
#include <zx_kernel_head.h>
#include <zx_system_calls.h>
#include <zx_ns_tree.h>
#include <zx_irq_device.h>
#include <zx_irq_vic.h>
#include <zx_timer.h>
#include <zx_clock_server.h>

/* for testing. Remove this when you finally run the kernel */
#include <zx_uart_io.h>
#include <zx_testing.h>

/*
 * This function is called before the kernel enters its infinite loop
 * of running tasks. This function does the following
 *
 * 1. Install SWI Handler
 * 2. Initialize the ready queue
 * 3a. Initialize few pesudo global variables which are stored in predefined 
 *    memory locations and accessed in kernel mode
 * 3b. Create the first user task for assignment 1
 * 
 */

void zx_kernel_init(int arg) {
	
	/* dummy condition, always evaluates to FALSE, but is needed to compile
	 * the assembly code and save_context_and_return_to_kernel(). otherwise 
	 * those parts of code will not be compiled, and handler will point not 
	 * to assembly code, but something other 
	 */
	if (arg < -1) 
	{
		goto handler;
	}

	goto end; /* skip assembly instructions */

/* EMBEDDED function starts here */
/* SWI handler in assemble language that calls the handler in C */

   int* magicPointer;
   int *var_addr;

/* This is the handler which is called when an SWI is generated by the 
 * user task. This handler saves the users registers onto users stack
 * and stores some registers (sp, spsr) in its stack so that they can
 * be stored in the td of user task in the function zx_switch_kernel_entry
 */
handler:

asm( 
   "nop\n\t"
   "nop\n\t"
   "nop\n\t"
   "nop\n\t"
   "nop\n\t"
   "nop\n\t" );

asm(
  
  /*----- This will point to supervisor stack if this is software interrupt ------- */
  /*----- If hardware interrupt, this will point to IRQ mode stack. So if in ------
    ----- IRQ mode, unload them from IRQ stack and load to supervisor stack ------- */
     
  "SUB sp, sp, #4\n\t" // decrease the stack pointer 
         
   /* In IRQ mode, we ll use IP as scratch register. So back it in IRQ's stack */                  
  "STMFD sp!, {ip}\n\t"    

     /* Back up r0-r3 and lr in IRQ s stack if in IRQ mode*/     
     "STMFD sp!, {r0-r3, lr}\n\t"    
  
     /* Store the SPSR from the user task to scratch register */
         "MRS r2, spsr \n\t"      
  
  /*----- This will point to supervisor stack if this is software interrupt ------- */
     
     /* Check if we are in SVC mode, which means that this is a Software Interrupt*/
         "MRS r0, CPSR \t\n"
         "AND r0, r0, #0x0000000f \t\n"
         "CMP r0, #3 \n\t"  
     /* If we came here because of software interrupt, go to generic handler */
         "BEQ svc_only_handler \n\t"
     
     /* We reached here by Hardware Interrupt */

     /* Move IP register to r1 */
        "mov r1, ip \n\t"                
               
     /* Go into supervisor mode */
        "MRS   r0, CPSR \n\t"
        "AND   r0,  r0, #0xfffffff0\n\t"
        "ORR   r0,  r0, #0x00000003\n\t"
        "MSR   CPSR, r0\n\t"  

     /* Copy supervisor's stack pointer to IP  */
        "mov ip, sp \n\t"
     /* Copy the SPSR we received in IRQ mode to SUpervisor's SPSR */   
        "MSR spsr, r2 \n\t"
         
     /* Switch back to IRQ mode */
        "MRS   r0, CPSR \n\t"
        "AND   r0,  r0, #0xfffffff0\n\t"
        "ORR   r0,  r0, #0x00000002\n\t"
        "MSR   CPSR, r0\n\t" 

//        "ldmfd sp!, {r0} \n\t" // load the label

        "mov r0, #123 \n\t" // IRQ label

        "stmfd ip!, {r0} \n\t" // push to the stack

     /* Move r1 which has the value of user's IP to supervisor's stack */
        "stmfd ip!, {r1} \n\t"
     
     /* Move the registers backed up in IRQ stack to supervisor stack */
     "ldmfd sp!, {r0-r3, lr} \n\t"
     "SUB lr, lr, #4 \t\n"
     "stmfd ip!, {r0-r3, lr} \n\t"
  
  /* Load IP which we stored in the beginning of the operation to r1 */
  "LDMFD sp!, {r1}\n\t" 
  
  "LDMFD sp!, {r0} \n\t" // dummy value          

  /* Switch to Supervisor mode */
  "MRS   r0, CPSR \n\t"
  "AND   r0,  r0, #0xfffffff0\n\t"
  "ORR   r0,  r0, #0x00000003\n\t"
  "MSR   CPSR, r0\n\t" 
   
  /* Move updated stack pointer of supervisor into it sp */ 
  "MOV sp, ip\n\t"
  
  /* Restore original IP when we entered this handler */
  "MOV ip, r1 \n\t"  
     
  "b generic_handler \n\t" // just go to the generic handler
     
     
"svc_only_handler: \n\t"

   "mov r0, #100 \n\t"
   "str r0, [sp, #24] \n\t"
                                     
"generic_handler: \n\t"

   /* Load from supervisor stack */
   "ldmfd sp!, {r0-r3, lr} \n\t"
   
   "LDMFD sp!, {ip}\n\t"      
   
// the state has just been restored completely

///////////////////////////////////////
// then as was before

/*(k0+)*/
"STMFD sp!, {r0-r3, lr}\n\t"  // needed for the argument and SWI number
      
  /*(k1+)*/    "STMFD sp!, {r0-r3}\n\t"  // store r0-r3 for the user


   /*(k2+)*/ "STMFD sp!, {ip}\n\t" // save user's IP in kernel's stack

     "mov r2, lr\n\t" // save return value

     /* Switch to the system mode */
     "MRS   r1,  CPSR\n\t"
     "ORR   r1,  r1, #0x0000000f\n\t"
     "MSR   CPSR, r1\n\t"         

  /* do stuff in SYSTEM mode */
  
              "STMFD sp!, {r2}\n\t" // store user's PC                                    PC
              "MOV r2, lr\n\t" // backup user's LR to r2
      
              "MOV ip, sp\n\t" // save the stack pointer   
     
     /* --- ATTENTION::::: ip HOLDS THE USER STACK POINTER!!!! --- */
         
     /*switch back to the supervisor mode */
     "MRS   r1, CPSR \n\t"
     "AND   r1,  r1, #0xfffffff0\n\t"
     "ORR   r1,  r1, #0x00000003\n\t"
     "MSR   CPSR, r1\n\t"  
  
  
   /*(k2-)*/ "LDMFD sp!, {r1}\n\t" // load IP from the kernel's stack

      "STMFD ip!, {r1}\n\t" // to the user stack. r0 - IS IP! So r12 is stored       r12
      
      "STMFD ip!, {r4-r11}\n\t" // to the user stack                                 r4 - r11
  
      "mov r5, r1\n\t" // save the backed up IP of the user.
      "mov r4, r2\n\t" // save the backed up LR of the USER to r4.
      
   /*(k1-)*/ "LDMFD sp!, {r0-r3}\n\t"  
  
             "STMFD ip!, {r0-r3}\n\t" //                                             r0-r3

             "STMFD ip!, {r4}\n\t" // USER: store LR                                 LR

     
  /* storing user SP onto kernel stack to store them in task descriptor*/
 /*(k3+)*/ "STMFD sp!, {ip}\n\t" // store user SP 

  /* storing user SPSR onto kernel stack to store them in task descriptor*/
           "MRS r1, spsr\n\t" // backup user SPSR             
 /*(k4+)*/ "STMFD sp!, {r1}\n\t" // store user SPSR 
   
 /*(k5+)*/ "STMFD sp!, {r5}\n\t" // store user IP (Jan 26) 

  /* branch to helper function that brings to the kernel entry */
  "B zx_save_context_and_return_to_kernel\n\t"
);

end:


/* 
 * Initialization Part -1 : Speed up everything
 */

   asm(
      "mov r0, #0 \n\t"
      "mrc p15, 0, r0, c1, c0\n\t"
      "orr r0, r0, #0x1000 \n\t" // bit 12: instruction cache
      "mcr p15, 0, r0, c1, c0\n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"

      "mov r0, #0 \n\t"
      "mrc p15, 0, r0, c1, c0\n\t"
      "orr r0, r0, #0x40000000 \n\t" // bit 30: nF bit
      "mcr p15, 0, r0, c1, c0\n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"

      "mov r0, #0 \n\t"
      "mrc p15, 0, r0, c1, c0\n\t"
      "orr r0, r0, #0x80000000 \n\t" // bit 31: iA bit
      "mcr p15, 0, r0, c1, c0\n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"
      "nop \n\t"

   );


/* 
 * Initialization Part 0 : Clean the variables
 */

   var_addr = (int*)(STAT_VAR1 );        
   *var_addr = 0x0;          

   var_addr = (int*)(STAT_VAR2 );        
   *var_addr = 0x0;              

   var_addr = (int*)(DEBUG_VAR_MISSED_INTR_CLOCK );        
   *var_addr = 0x0;  

   var_addr = (int*)(DEBUG_VAR_MISSED_INTR_UART1_TX );        
   *var_addr = 0x0;  

   var_addr = (int*)(DEBUG_VAR_MISSED_INTR_UART1_RX );        
   *var_addr = 0x0;  

   var_addr = (int*)(DEBUG_VAR_MISSED_INTR_UART2_TX );        
   *var_addr = 0x0;  

   var_addr = (int*)(DEBUG_VAR_MISSED_INTR_UART2_RX );        
   *var_addr = 0x0;  
      
   int i = 0;
      
   for (i = 0; i < 5; i++)
   {
      var_addr = (int*)(DEBUG_VAR_BASE + 5 * 4 + i * 4);        
      *var_addr = 0x0;  
   }

   /* Make sure that we are writing on a clean slate
    * Interrupts should be disbaled in the VIC
    * Interrupts should be disabled in the devices
    * Interrupt lines of the devices need to low
    */


/* 
 * Initialization Part 1 : Reset the interrupts
 */
   
   zx_timer_disable(IRQ_TIMER); 
   zx_timer_disable(IDLE_TASK_TIMER); 
      
   zx_reset_all_interrupts();   
   



/* 
 * Initialization Part 2 :  Install the handler. For this, we modify the 
 * instruction at 0x08. During each SWI, the instruction at this location
 * is executed. From here we branch to the handler 
 */
   
   /* SWI Handler Installation.
    * We go to memory location 0x08 (magic pointer) and replace
    * the instruction there. The replaced instruction causes the 
    * program to jump to SWI handler above whenever SWI is 
    * generated 
    */
	magicPointer = (int*) (SWI_VECTOR);
	void *functionAddress;
	functionAddress = &&handler;
	int value = ((int)functionAddress);

   value = value - 0x08 - 0x8;
	value = (value >> 2); // shift right
	value |= 0xEA000000; // B instruction
	*magicPointer = value;



   /* IRQ Handler Installation.
    * We go to memory location 0x08 (magic pointer) and replace
    * the instruction there. The replaced instruction causes the 
    * program to jump to SWI handler above whenever SWI is 
    * generated 
    */
	magicPointer = (int*) (IRQ_VECTOR);
	functionAddress = &&handler;
	value = ((int)functionAddress);

   value = value - 0x18 - 0x8;
	value = (value >> 2); // shift right
	value |= 0xEA000000; // B instruction
	*magicPointer = value;

		
	  // bwprintf( COM2, "HELLO_HELLO! root = %x \n", 340);
/* 
 * Initialization Part 3 : initilalize task descriptors
 */


   for( i =0 ; i<TASK_COUNT; i++ )
   {
      zx_td *td = zx_get_td(i);
      td->tid = ( 0xffffff00 | i );
      td->state = TASK_STATE_ZOMBIE;
   }

/* 
 * Initialization Part 4 : Install the receive queue
 *
 */ 
   i = 0;
   int* recv_q_head_addr = zx_receive_q_get_head_addr(0);
    
   for( i = 0; i < TASK_COUNT; i++ )
   {
      *recv_q_head_addr = NULL;
      recv_q_head_addr++;
   }   
   int* recv_q_tail_addr = zx_receive_q_get_tail_addr(0);
    
   for( i = 0; i < TASK_COUNT; i++ )
   {
      *recv_q_tail_addr = NULL;
      recv_q_tail_addr++;
   }  

/* 
 * Initialization Part 5 : Install the ready queue
 *
 */ 
   i = 0;
   int* head_addr = zx_q_get_head_addr(0);
    
   for( i = 0; i < PRIORITY_COUNT; i++ )
   {
      *head_addr = NULL;
      head_addr++;
   }

/* 
 * Initialization Part 6 : Create first user task and put it into the ready list
 */   
   int *priority = (int*)(PRIORITY_BIT_DATA);
   *priority = 0;

   unsigned long long *td_bit_data = (unsigned long long*)(TD_BIT_DATA);
   unsigned long long all_on_64 = (unsigned long long)(-1);
   
   *td_bit_data =  all_on_64;

   int tid_first = zx_create( FIRST_USER_TASK_PRIORITY, &FIRST_USER_TASK );           
   zx_q_append_to_end( tid_first, FIRST_USER_TASK_PRIORITY );    
   
   /* Initializing TASK IDs */
   int* addr = (int*)(AWAIT_TIMER_TID); 
   *addr = INVALID_TASK_ID;
   addr = (int*)(AWAIT_UART1_TX_TID); 
   *addr = INVALID_TASK_ID;   
   addr = (int*)(AWAIT_UART1_RX_TID); 
   *addr = INVALID_TASK_ID;   
   addr = (int*)(AWAIT_UART2_TX_TID); 
   *addr = INVALID_TASK_ID;   
   addr = (int*)(AWAIT_UART2_RX_TID); 
   *addr = INVALID_TASK_ID;      
   
   
  /*
   * Initialization Part 7 : Creating Idle Task 
   */
   
   /* initially, time spent on idle task is  0 */
   int *idle_task_timer_addr = (int*)VAR_IDLE_TASK_TIME;
   *idle_task_timer_addr = 0;
   
   /* Create idle task */
   zx_create( IDLE_TASK_PRIORITY, &zx_idle );           
   zx_q_append_to_end( IDLE_TASK_TID, IDLE_TASK_PRIORITY );
   

  /*
   * Initialization Part 8 : Initialize devices and enable interrupts 
   */
   
   /* Enable UART2 */
   zx_initialize_uart2();   
   
   /* Enable UART1 */
   zx_initialize_uart1();
   
   /* Enable Hardware Interrupts */
   zx_vic_enable_all_interrupts();   
   
   
	return;
}

/*
 * This is the function is called by the main kernel loop to handle the 
 * system calls  request (SWI) by the user task.
 */
void zx_handle( void *req )
{
   int tid;
	int result;
   zx_td *mytd;
   int *pointer;
   
   zx_request *request = (zx_request*)req;  
	
	switch (request->swi_number)
   {   
      case SWI_CREATE_TASK: /* Create( int priority, void *code()) Handler */
	      tid = zx_create( (int)(request->arg1), (void*)request->arg2 );
	      zx_q_append_to_end( tid, (int)(request->arg1) );        	
	      
	      mytd = zx_get_active_td();
	      mytd->return_value = tid;
	 	      
         break;

	   case SWI_PASS: /* Pass() Handler */
	      /* :) Ya..Do nothing. 
	       * Simply let the scheduler to find the next task to run 
	       */           
      break; 
	      
	   case SWI_EXIT: /* Exit() Handler */
	      zx_exit();
	      break;
	      
	   case SWI_MYTID: /* MyTid() Handler */
	      tid = zx_my_tid();
         mytd = zx_get_active_td();
	      mytd->return_value = tid;  
         break;
	      
	   case SWI_MYPTID: /* MyParentTid() Handler */
	      tid = zx_parent_tid();
	      mytd = zx_get_active_td();
	      mytd->return_value = tid;
	      break;
	      
	   /* for Send(), Receive() and Reply(), we handle the return values in respective handlers */
	   
	   case SWI_SEND: /* Send() Handler */
	      zx_send( (int)(request->arg1), (char*)request->arg2, (int)(request->arg3), 
	                        (char*)request->arg4, (int)(request->arg5) );
	  
	      break;
	      
	   case SWI_RECEIVE: /* Receive() Handler */ 
	      zx_receive( (int*)(request->arg1), (char*)request->arg2, (int)(request->arg3) );
//	      bwprintf( COM2, "zx_handle : Receive returned\n\r");
	      break;
	      
	   case SWI_REPLY: /* Reply() Handler */
	      zx_reply( (int)(request->arg1), (char*)request->arg2, (int)(request->arg3) );
//	      bwprintf( COM2, "zx_handle : Reply returned\n\r");
	      break;
	      
	   case SWI_ALLOC: /* Alloc() Handler */
	      pointer = (int*)zx_alloc();
	      mytd = zx_get_active_td();
	      mytd->return_value = (int)pointer;
	      break;
	      
	   case SWI_FREE: /* Free() */
	      zx_free( (void*)(request->arg1) ); 
	      break;

	   case SWI_AWAIT_EVENT:
	      zx_await_event((int)(request->arg1));
	      break;

	   case SWI_SHUTDOWN:
	      zx_shutdown();
	      break;	
	      
	   case SWI_KILL:
	      zx_kill((int)(request->arg1));       
	      
	   case HWI:
//	      asm("MOV pc, #0\n\t");
	      zx_handle_hwi((int)(request->arg1));
//   	   bwprintf(COM2, "HWI!\n");
   	   break;
	      
	   case DEBUG_SWI_MANYARGS: /* Debugging the call of many arguments */
	      result = debug_many_args(req);
	      mytd = zx_get_active_td();
	      mytd->return_value = result;
	      break;

	   default:
//	      bwprintf(COM2, "Unsupported: %d.", request->swi_number);
//	      bwgetc(COM2);
	      break;
   }
}

/* 
 * This function checks whether there are errors when there are no tasks in the ready queue
 */
zx_request* zx_get_closure_errors()
{
   int error = SWI_NONE;   
   int i;
   
   for (i = 0; i < TASK_COUNT; i++)
   {
      zx_td* td = zx_get_td(i);
      if (TASK_STATE_SEND_BLOCKED == td->state)
      {
         bwprintf(COM2, "Warning: task '%d' is in SEND_BLOCKED state.\n", td->tid);
         error = SWI_ERROR;
      }
      else if (TASK_STATE_RECEIVE_BLOCKED == td->state)
      {
         bwprintf(COM2, "Warning: task '%d' is in RECEIVE_BLOCKED state.\n", td->tid);
         error = SWI_ERROR;
      }
      else if (TASK_STATE_REPLY_BLOCKED == td->state)
      {
         bwprintf(COM2, "Warning: task '%d' is in REPLY_BLOCKED state.\n", td->tid);
         error = SWI_ERROR;
      }
      else if (TASK_STATE_EVENT_BLOCKED == td->state)
      {
         bwprintf(COM2, "Warning: task '%d' is in EVENT_BLOCKED state.\n", td->tid);
         error = SWI_ERROR;
      }   
   }
   
   zx_request *req_structure = (zx_request*) (REQUEST_STRUCTURE); 
   req_structure->swi_number = error;   
   
   return req_structure;
}

/* 
 * This function finds the next task to exectued from the priority queue.
 * and executes it. It gets back zx_request structure when the restored
 * task generates SWI structure
 */
zx_request* zx_get_next_request()
{
   /* Get the ID of next task to be executed */
   int tid = zx_q_get_next_tid(); 

       //  zx_reset_all_interrupts(); 
//         int *addr = (int*)TEMP_VAR3;
//         *addr = tid;   
   
   if (tid != -1) //there are tasks to run
   {
   
      /* ---------------------------------------- */
      /* Are we going to restore the IDLE task ?? */
      if( tid == IDLE_TASK_TID )
      {         
         /* If we are going to restore the IDLE task
            start profiling
          */
         zx_timer_load_val( IDLE_TASK_TIMER, IDLE_TASK_TIMER_INIT_VAL );
         zx_timer_set_periodic( IDLE_TASK_TIMER, ON );            
         zx_timer_select_clock( IDLE_TASK_TIMER, TIMER_508KHZ_CLKSEL_MASK ); 
         zx_timer_enable( IDLE_TASK_TIMER );
      }
      /* ---------------------------------------- */         
         
      /* Restore the user task */
      zx_request* req = zx_restore_context(tid);
      
      
      /*
       * Return the zx_request structure filled with swi number 
       * and system call arguments 
       */ 
      return req;
	}
	else
	{
	   return NULL; //closure_req;
	}
}

/*
 * This fucntion does 3 tasks
 * 1. Save the SPSR, SP of the interrupted user task to the task descriptor of the task
 * 2. Fill the values of the zx_request structure so that the SWI number and the 
 *    arguments of the system call would be passed to the kernel's loop and handled
 * 3. Return the structure to the kernel's loop
 *
 * Return value : zx_request containing SWI number and arguments of the system call
 */
zx_request* zx_save_context_and_return_to_kernel()
{

   // definitions do not corrupt registers   
   int sp;
   int ip;
   int spsr;
   int indicator;
      
   int r0;
   int r1;
   int r2;
   int r3;         

   int lr;
   int swi_number;   
   int instruction = 0;

   // Alex:changed loading registers so that none of them is corrupted. 
   // Because inline asembly uses r3, so that it is lost if we load everything at once
   
   asm(
      // get USER IP back
      /*(k5-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(ip)
   );

   asm(
      // get USER SPSR back
      /*(k4-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(spsr)
   );

   asm(
      // get USER SP back
      /*(k3-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(sp)
   );

   asm(
      // get R0 back
      /*(k0-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(r0)
   );

   asm(
      // get R1 back
      /*(k0-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(r1)
   );

   asm(
      // get R2 back
      /*(k0-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(r2)
   );

   asm(
      // get R3 back
      /*(k0-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(r3)
   );

   asm(
      // get LR back
      /*(k0-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(lr)
   ); 
   
   asm(
      // get LR back
      /*(k0-)*/
      "LDMFD ip!, {r0}\n\t" 
      "MOV %[v], r0" : [v]"=r"(indicator)
   );        

      /* -----------------------------------------------------------------------------*/
      /* get the swi number */
      /* ATTENTION : Dont ever put this code after a function call which ll 
       * invariably   corrupt the LR 
       */         
   asm("LDR %[v], [lr, #-4]" : [v]"=r"(instruction));   

   asm(
   "NOP \n\t"
   "NOP \n\t"
   "NOP \n\t"      
   );  

   /* ASSEMBLY ENDS!!! YES!!! */

   //bwprintf(COM2, "HERE!!! %x\n", swi_number);
   swi_number = instruction & 0x00ffffff; //get higer order bits

   instruction &= 0x0f000000; // get the instrcution
      
   /* -----------------------------------------------------------------------------*/   
   
   // get the TD of the active task (the one that generated the interrupt)
   zx_td* td = zx_get_active_td(); 
   
   td->return_value = r0; 
   td->sp = (int*)sp;   
   td->spsr = spsr; 

   /* request structure containing the arguments of swi number should be returned
    * back to the handler
    */
   zx_request *req_structure = (zx_request*) (REQUEST_STRUCTURE); 
   req_structure->arg1 = (int*)r0;
   req_structure->arg2 = (int*)r1;
   req_structure->arg3 = (int*)r2;
   req_structure->arg4 = (int*)r3;

   if( indicator != 123 ) // swi
   {

     int* arg5 = (int*)(ip + 0);
//   int* arg6 = (int*)(ip + 4);
//   int* arg7 = (int*)(ip + 8);
         
     req_structure->arg5 = (int*) (* arg5 );
   }
   else 
     req_structure->arg5 = 0;
        
//   req_structure->arg6 = (int*) (* arg6 );
//   req_structure->arg7 = (int*) (* arg7 );   


//   bwprintf(COM2, "Indicator: %d\n", indicator);

   /*----------------------------------------------*/
   /* Are we saving the context of Idle Task ?? */
   if( td->tid == IDLE_TASK_TID )
   {
         
      /* Disable the timer */
      zx_timer_disable( IDLE_TASK_TIMER );
   
      /* Collect Statistics */
      int timer_value = zx_timer_get_value( IDLE_TASK_TIMER );      
      int millisecs = (IDLE_TASK_TIMER_INIT_VAL-timer_value)/ONE_MILLISECOND_TICK;
    
      int *idle_task_time = (int*)(VAR_IDLE_TASK_TIME);
      *idle_task_time =  *idle_task_time + millisecs;
   
      int *debug = (int*)(DEBUG_VAR_30);
      *debug =  0x12345678;
      
   
   }
   /*----------------------------------------------*/

   if( indicator == 123 ) // hwi
   {
      /* Move this code to service routine */
      int device_number = zx_get_interrupt_source();    
      
      /* We ll clear the interrupt as soon as we
         receive them
       */  
      zx_device_intr_clear (device_number);

      swi_number = HWI;
      req_structure->arg1 = (int*)device_number;      
   }
   
   else 
   {
//      bwprintf(COM2, "SWI!!!!!\n");
//      bwprintf(COM2, "SWI: Registers %x, %x,%x,%x, %x\n", r0, r1, r2, r3, swi_number);
   }
   
   req_structure->swi_number = swi_number;    
   
   int req_address = (int)req_structure;
      
//   bwprintf(COM2, "BEFORE ASM %x, %x,%x,%x\n", r0, r1, r2, r3);
   
   /* RETURNING the request structure to get_next_request by moving it to r0 */
   asm("MOV r0, %[v]" : [v]"=r"((int)req_address));
   
   /* cancel what is done at the top of this function */
   asm(  
	"sub	sp, fp, #16 \n\t"
	"ldmfd	sp, {sl, fp, sp} \n\t"
	
	"ldmfd	sp!, {r4} \n\t"	
	"ldmfd	sp!, {r4} \n\t"	
	"ldmfd	sp!, {r4} \n\t"	
	"ldmfd	sp!, {r1-r4, lr} \n\t"			
	"ldmfd	sp!, {r4} \n\t"	// just dummy value
	
//	"ldmfd	sp!, {r1} \n\t"	// scpsr
   ); 
   
   /* Loading kernel stack back to the registers. This is stored before switching to
    * user_mode in zx_restore_context()
    */
   /*(k6-)*/
   asm("ldmfd sp!, {r4-r12, lr}\n\t ");
   
   /* now cancel what is done by zx_restore_context
    * These lines of the code make get_next_request() believe that it
    * got the request structure back from zx_restore_context() . But zx_restore_context()
    * just restores context of a user task. We get here after that user task
    * gives up the system to kernel by calling a system call
    */
   asm(  
	"sub	sp, fp, #12 \n\t"
	"ldmfd	sp, {fp, sp, pc} \n\t"
   ); 
   

   asm(
   "NOP \n\t"
   "NOP \n\t"
   "NOP \n\t"      
   );
  
   /* 
    * Below statments never execute. They are here just to trick 
    * the compiler to believe that we indeed return something
    */ 
   zx_request *req = (zx_request*) (REQUEST_STRUCTURE);   
   
   return req;
}

/* 
 * This function restores the user task corresponding to given tid.
 * This is called by get_next_request which gets the next highest
 * priority task from the queue. This function activates that next
 * highest priority task
 */
zx_request* zx_restore_context(int tid)
{

   /* DO NOT USE BWPRINTF INSIDE THIS FUNCTION !!!!!!!!! */

   /* If you are trying to debug this function, dont add any 
    * bwprintf statements here. This ll change the end last
    * 2 instructions needed to back to the caller function.
    * And we have hard coded these instructions in the 
    * zx_switch_kernel_entry function. And if you try to 
    * do, you ll break the kernel code and have hard time 
    * debugging it
    */
   
   zx_set_active_task_id(tid);

   /* Saving kernel context. This will be restored when we get back
    * to the kernel after an SWI is generated. This is the way to get
    * back to the kernel loop. 'lr' will take us back to the 
    * zx_get_next_request() from zx_save_context_and_return_to_kernel()
    */
   /*(k6+)*/
   asm("stmfd sp!, {r4-r12, lr}\n\t");
   
   /* Reading the main register values from task descriptor of the task
    * that has to be retored
    */
   zx_td* mytd = zx_get_active_td();
   /* reading return value to be later saved to r0*/
   int retval  = mytd -> return_value; 
    
   asm("mov r1, %[v]" : [v]"=r"(retval)); 	   
   asm("stmfd sp!, {r1}"); /*(k7+)*/
   
   int spsr    = mytd -> spsr;
   /* Saved Program Status Register when the user task ran previously */
   asm("mov r1, %[v]" : [v]"=r"(spsr)); 	   
   asm("stmfd sp!, {r1}"); /*(k8+)*/

   int sp      = (int)mytd -> sp;
   /* Stack pointer of the user task */
   asm("mov r5, %[v]" : [v]"=r"(sp));


   asm(		   		  	
   
   /* Switch to the SYSTEM MODE */
     "MRS   r4,  CPSR\n\t"
     "ORR   r4,  r4, #0x0000000f\n\t"
     "MSR   CPSR, r4\n\t"   

   /* In SYSTEM MODE */
     "mov sp, r5 \n\t"     /* restoring the user SP */   
     "LDMFD sp!, {lr}\n\t" // we have got user's LR back. It is good     
     "LDMFD sp!, {r0-r3}\n\t" // load the user's r0 - r3
     
   /* switch back to the SUPERVISOR MODE */
     "MRS   r4, CPSR\n\t"                     
     "AND   r4,  r4, #0xfffffff0\n\t"
     "ORR   r4,  r4, #0x00000003\n\t"
     "MSR   CPSR, r4\n\t"  

   /* In Supervisor MODE */

     "ldmfd sp!, {r4}  \n\t" /*(k8-)*/ // load SPSR     
     "STMFD sp!, {r0-r3}\n\t" // we have from r0 to r3, store them   
     
      // NOW WE CAN USE r0-r3 freely
          
     "mov r2, r4\n\t" // copy SPSR
     
     
   /* Switch to the SYSTEM MODE */
          
     "MRS   r0,  CPSR\n\t"
     "ORR   r0,  r0, #0x0000000f\n\t"
     "MSR   CPSR, r0\n\t"   

   /* In SYSTEM MODE */          
     "LDMFD sp!, {r4-r11}\n\t"   // load the user's r4 - r11     
     "LDMFD sp!, {ip}\n\t"       // load the user's ip    
      
     "LDMFD sp!, {r1}\n\t"       // load the user's PC 
     
     /* now r1 - User's PC    */
     /* now r2 - user's CPSR  */      
                  
   /* switch back to the SUPERVISOR MODE */
     "MRS   r0, CPSR\n\t"                     
     "AND   r0,  r0, #0xfffffff0\n\t"
     "ORR   r0,  r0, #0x00000003\n\t"
     "MSR   CPSR, r0\n\t"                    
                  
     /* Restoring SPSR of the user */
     "msr spsr, r2 \n\t"       
     "mov lr, r1   \n\t"                // put user's pc into lr
     
     "LDMFD sp!, {r0-r3}\n\t" // load what is left
     
     "ldmfd sp!, {r0}  \n\t"    /*(k7-)*/    
     
     // debug
/*     
     "stmfd sp!, {r0} \n\t"     
     "mov r0, #0x00218000 \n\t"     
     "cmp lr, r0 \n\t"
     "ldmfd sp!, {r0} \n\t"
     "bne lbl\n\t"
//     "mov ip, sp\n\t"    
//     "mov pc, #0x00218000 \n\t"     
     "lbl:"
     /// debug  
*/
/*
         "stmfd sp!, {r0-r12, lr} \n\t"
         "mov r0, #1 \n\t"
         "ldr r1, =0x11111111 \n\t"
         "bl bwputr \n\t"
         "ldmfd sp!, {r0-r12, lr} \n\t"    

         "stmfd sp!, {r0-r12, lr} \n\t"
         "mov r0, #1 \n\t"
         "mov r1, ip \n\t"
         "bl bwputr \n\t"
         "ldmfd sp!, {r0-r12, lr} \n\t"    
*/

     "MOVS pc, lr \n\t"               
  );
                    
   /* 
    * Below statments never execute. They are here just to trick 
    * the compiler to believe that we indeed return something
    *
    * LABEL!!! 
    * zx_restore_context_leave:
    * the end of the function 
    */ 
  
	//sub	sp, fp, #12
	//ldmfd	sp, {fp, sp, pc}
	return NULL;    
}

/* Idle task code */
/* Ended up making as a function call of a call. Too tired to move it back..
 * May be for the next assignment 
 */
void truly_idle_()
{
    /* ------- Infinite Loop --------*/
    while(1)
    {

    }
    /*-------------------------------*/ 
}


/* Idle Task Runs Infinitely */
void zx_idle()
{
   truly_idle_();
}




